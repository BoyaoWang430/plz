<script type="text/x-template" id="log-viewer-template">
    <div>
        <el-row>
            <el-col :span="20">
                <el-switch
                        v-model="autoUpdate"
                        active-text="Auto Update"
                        style="float: right;">
                </el-switch>
                <div style="clear: both;"></div>
                <el-table
                        ref="viewer"
                        :data="viewerData"
                        :row-key="getRowKey"
                        style="width: 100%;">
                    <el-table-column type="expand">
                        <template slot-scope="tbl">
                            <span v-for="kv in formatKV(tbl.row)" class="event-kv">{{ kv }}</span>
                        </template>
                    </el-table-column>
                    <el-table-column label="timestamp" :formatter="formatTimestamp" width="140" v-if="showTimestamp"/>
                    <el-table-column label="level" width="140" v-if="showLevel">
                        <template slot-scope="tbl">
                            <span :class="'level level-' + tbl.row.level">{{ tbl.row.level }}</span>
                        </template>
                    </el-table-column>
                    <el-table-column v-for="item in userDefinedColumns" :prop="item" :key="item" :label="item" resizable/>
                    <el-table-column label="event" prop="event">
                        <template slot-scope="scope">
                            <span class="event-cell">{{ scope.row.event }}</span>
                        </template>
                    </el-table-column>
                </el-table>
            </el-col>
            <el-col :span="4" style="pdding-right: 1em; padding-left: 1em;">
                <data-sources :dataSource.sync="dataSource"/>
                <columns ref="columns" :namespace="dataSource"
                         :columns.sync="userDefinedColumns"
                         :showTimestamp.sync="showTimestamp"
                         :showLevel.sync="showLevel"
                         :propKeys="propKeys" @expandAll="expandAll"/>
                <filters :propValues="propValues" :filters.sync="filters"/>
            </el-col>
        </el-row>
    </div>
</script>
<style>
    .level-FATAL {
        background-color: red;
    }

    .level-ERROR {
        background-color: #ff9999;
    }

    .level-WARN {
        background-color: #ffc8c8;
    }

    .event-kv {
        margin-right: 1em;
        padding: 4px;
        color: #ccc;
    }

    tr:hover .event-kv {
        background-color: #eee;
        color: #000;
    }

    .event-cell {
        padding: 4px;
        background-color: #eee;
    }

    .el-table__expanded-cell[class*=cell] {
        padding: 4px 0;
    }

    .el-table td, .el-table th {
        padding: 2px 0;
    }
</style>
<script>
    Vue.component('log-viewer', {
        template: '#log-viewer-template',
        data: function () {
            return {
                /* controls the ui layout */
                userDefinedColumns: [],
                hiddenKeys: {
                    'level': true,
                    '__filtered_by_0': true,
                    'timestamp': true,
                    'lineNumber': true,
                    'event': true
                },
                showTimestamp: false,
                showLevel: false,
                /* how to fill the events */
                dataSource: window.location.host,
                propValues: {}, // property dictionary, only keep last 100 unique values
                events: [], // the backing data store, only events in the window range is filled into viewer
                /* how to fill the viewer data */
                autoUpdate: true,
                filters: {'cacheKey': '__filtered_by_0'},
                viewerData: [], // the actual viewer data, will be refilled to match offset/window
                viewerOffset: 0, // [viewerOffset, viewerOffset+viewerWindow) defines the expected viewer data
                viewerWindow: 100
            }
        },
        watch: {
            dataSource: function () {
                this.events = [];
                this.propValues = [];
                this.userDefinedColumns = [];
            },
            filters: function() {
                this.updateViewerData();
            }
        },
        methods: {
            getRowKey: function(row) {
                return row.timestamp;
            },
            formatTimestamp: function (row, column, cellValue) {
                var d = new Date(row.timestamp / 1000000);
                return d.getHours() + ':' + d.getMinutes() + ':' + d.getSeconds() + '.' + d.getMilliseconds();
            },
            formatKV: function (event) {
                var kv = [];
                for (var propKey in event) {
                    if (this.hiddenKeys[propKey]) {
                        continue;
                    }
                    if (this.userDefinedColumns.indexOf(propKey) !== -1) {
                        continue;
                    }
                    var propValue = event[propKey];
                    kv.push(propKey + '=' + propValue);
                }
                return kv;
            },
            isFiltered: function (event, cacheKey) {
                var cacheValue = event[cacheKey];
                if (cacheValue !== undefined) {
                    return cacheValue;
                }
                for (var propKey in this.filters) {
                    if (propKey === 'cacheKey') {
                        continue;
                    }
                    var filterFunc = this.filters[propKey];
                    var propValue = event[propKey];
                    if (propValue === undefined) {
                        event[cacheKey] = true;
                        return true;
                    }
                    if (!filterFunc(propValue)) {
                        event[cacheKey] = true;
                        return true;
                    }
                }
                event[cacheKey] = false;
                return false;
            },
            expandAll: function (e) {
                this.$refs.viewer.$data.store.states.defaultExpandAll = e;
                var tableData = this.tableData;
                for (var i in tableData) {
                    this.$refs.viewer.toggleRowExpansion(tableData[i], e);
                }
            },
            handleScroll: function() {
                this.autoUpdate = false;
            },
            updateViewerData: function() {
                var count = 0;
                var filtered = [];
                var cacheKey = this.filters['cacheKey'];
                this.hiddenKeys[cacheKey] = true;
                if (this.autoUpdate) {
                    this.viewerOffset = this.events.length;
                }
                for (var i = this.viewerOffset - 1; i >= 0; i--) {
                    var event = this.events[i];
                    if (this.isFiltered(event, cacheKey)) {
                        continue;
                    }
                    filtered.push(event);
                    count++;
                    if (count === this.viewerWindow) {
                        break;
                    }
                }
                this.viewerData = filtered;
            }
        },
        computed: {
            propKeys: function () {
                var keys = ['timestamp', 'level'];
                for (var propKey in this.propValues) {
                    if (propKey === 'event') {
                        continue;
                    }
                    keys.push(propKey);
                }
                return keys;
            }
        },
        created: function () {
            window.addEventListener('scroll', this.handleScroll);
            var me = this;
            (function () {
                var callback = arguments.callee;
                axios.get('http://' + me.dataSource + '/more-events?ts=' + Date.now())
                    .then(function (resp) {
                        if (!resp || !Array.isArray(resp.data)) {
                            setTimeout(callback, 10000);
                            return
                        }
                        for (var i in resp.data) {
                            var event = resp.data[i];
                            for (var propKey in event) {
                                if (propKey === 'level' || propKey === 'timestamp' || propKey === 'lineNumber') {
                                    continue;
                                }
                                var propValue = event[propKey];
                                if (!(propKey in me.propValues)) {
                                    Vue.set(me.propValues, propKey, []);
                                } else {
                                    var vals = me.propValues[propKey];
                                    if (vals.length < 100 && vals.indexOf(propValue) === -1) {
                                        vals.push(propValue);
                                    }
                                }
                            }
                        }
                        me.events = me.events.concat(resp.data);
                        me.updateViewerData();
                        setTimeout(callback, 0);
                    });
            })();
        },
        destroyed: function() {
            window.removeEventListener('scroll', this.handleScroll);
        }
    });
</script>